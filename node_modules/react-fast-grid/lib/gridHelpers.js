"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const createSpacing_1 = __importDefault(require("./createSpacing"));
const createBreakPoints_1 = __importDefault(require("./createBreakPoints"));
const breakpoints = createBreakPoints_1.default({
    values: {
        xs: 0,
        sm: 600,
        md: 960,
        lg: 1280,
        xl: 1920,
    },
    unit: "px",
    step: 5,
});
exports.breakpoints = breakpoints;
const spacingFunction = createSpacing_1.default(8);
const SPACINGS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const GRID_SIZES = ["auto", true, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
function generateGrid(globalStyles, breakpoint, baseStyles) {
    const styles = {};
    const COLUMN_CLASS = "direction-xs-column";
    GRID_SIZES.forEach((size) => {
        const key = `grid-${breakpoint}-${size}`;
        if (size === true) {
            // For the auto layouting
            styles[key] = {
                flexBasis: 0,
                flexGrow: 1,
                maxWidth: "100%",
            };
        }
        else if (size === "auto") {
            styles[key] = {
                flexBasis: "auto",
                flexGrow: 0,
                maxWidth: "none",
            };
        }
        else if (typeof size === "number") {
            // Keep 7 significant numbers.
            const computedSize = `${Math.round((size / 12) * 10e7) / 10e5}%`;
            // Close to the bootstrap implementation:
            // https://github.com/twbs/bootstrap/blob/8fccaa2439e97ec72a4b7dc42ccc1f649790adb0/scss/mixins/_grid.scss#L41
            styles[key] = {
                flexBasis: computedSize,
                flexGrow: 0,
                maxWidth: computedSize,
            };
        }
        styles[COLUMN_CLASS] = Object.assign(Object.assign({}, styles[COLUMN_CLASS]), { ["& > $" + key]: Object.assign(Object.assign({}, styles[key]), { maxWidth: "unset", maxHeight: styles[key].maxWidth }) });
    });
    // No need for a media query for the first size.
    if (breakpoint === "xs") {
        Object.assign(globalStyles, Object.assign(Object.assign({}, styles), { [COLUMN_CLASS]: Object.assign(Object.assign({}, baseStyles[COLUMN_CLASS]), styles[COLUMN_CLASS]) }));
    }
    else {
        globalStyles[breakpoints.up(breakpoint)] = styles;
    }
}
exports.generateGrid = generateGrid;
function getOffset(val, div = 1) {
    const parse = parseFloat(val);
    return `${parse / div}${String(val).replace(String(parse), "") || "px"}`;
}
exports.getOffset = getOffset;
function generateGutter(breakpoint) {
    const styles = {};
    SPACINGS.forEach((spacing) => {
        const themeSpacing = spacingFunction(spacing);
        if (themeSpacing === 0) {
            return;
        }
        styles[`spacing-${breakpoint}-${spacing}`] = {
            margin: `-${getOffset(themeSpacing, 2)}`,
            width: `calc(100% + ${getOffset(themeSpacing)})`,
            "& > $item": {
                padding: getOffset(themeSpacing, 2),
            },
        };
    });
    return styles;
}
exports.generateGutter = generateGutter;
