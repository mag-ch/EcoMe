"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const createBreakPoints_1 = require("./createBreakPoints");
const gridHelpers_1 = require("./gridHelpers");
const debounce_1 = __importDefault(require("./debounce"));
let keysDsc = [...createBreakPoints_1.keys].reverse();
let listeners = [];
if (typeof window.matchMedia === "function") {
    for (const [i, key] of createBreakPoints_1.keys.entries()) {
        const start = key;
        const end = createBreakPoints_1.keys[i + 1];
        const media = window.matchMedia(gridHelpers_1.breakpoints.between(start, end).replace("@media", "").trim());
        media.addListener(() => {
            if (process.env.NODE_ENV !== "production") {
                console.log("Fired listener for media items");
            }
            for (const listener of listeners) {
                listener();
            }
        });
    }
}
else {
    window.addEventListener("resize", () => {
        for (const listener of listeners) {
            listener();
        }
    }, false);
}
const upFrom = (breakpoint) => {
    return createBreakPoints_1.keys.slice(createBreakPoints_1.keys.indexOf(breakpoint));
};
const downFrom = (breakpoint) => {
    return createBreakPoints_1.keys.slice(0, createBreakPoints_1.keys.indexOf(breakpoint) + 1);
};
const upDownMap = {
    xsUp: upFrom("xs"),
    xsDown: downFrom("xs"),
    smUp: upFrom("sm"),
    smDown: downFrom("sm"),
    mdUp: upFrom("md"),
    mdDown: downFrom("md"),
    lgUp: upFrom("lg"),
    lgDown: downFrom("lg"),
    xlUp: upFrom("xl"),
    xlDown: downFrom("xl"),
};
class Hidden extends React.Component {
    constructor(props) {
        super(props);
        this._getBreakPoint = (width) => {
            const breakPointValues = gridHelpers_1.breakpoints.values;
            for (const key of keysDsc) {
                if (width >= breakPointValues[key]) {
                    return key;
                }
            }
            return "xl";
        };
        this._getTrueKeyInProp = () => {
            const props = this.props;
            for (const key in upDownMap) {
                // @ts-ignore
                if (props[key] === true) {
                    return key;
                }
            }
            return null;
        };
        this._isVisible = (breakPoint) => {
            const { only } = this.props;
            if (Array.isArray(only)) {
                return only.includes(breakPoint);
            }
            else if (typeof only === "string") {
                return only === breakPoint;
            }
            const trueKey = this._getTrueKeyInProp();
            if (trueKey !== null) {
                return upDownMap[trueKey].includes(breakPoint);
            }
            return false;
        };
        this._lastBreakPoint = null;
        this._onResize = () => {
            const width = window.innerWidth;
            const breakPoint = this._getBreakPoint(width);
            if (this._lastBreakPoint === breakPoint) {
                return;
            }
            const lastVisible = this.state.visible;
            const nextVisible = this._isVisible(breakPoint);
            if (lastVisible !== nextVisible) {
                this.setState({ visible: nextVisible });
            }
            this._lastBreakPoint = breakPoint;
        };
        this._onResizeInvoker = () => this._onResizeDebounced();
        const width = window.innerWidth;
        const breakPoint = this._getBreakPoint(width);
        this.state = {
            visible: this._isVisible(breakPoint),
        };
        const { debounce = 5 } = props;
        this._onResizeDebounced = this._getSafeDebounceResize(this._onResize, debounce);
    }
    _getSafeDebounceResize(callback, timeout) {
        return typeof timeout === "number" && timeout > 0
            ? debounce_1.default(callback, timeout)
            : callback;
    }
    componentWillReceiveProps(nextProps) {
        const { debounce = 5 } = nextProps;
        if (this.props.debounce !== debounce) {
            this._onResizeDebounced = this._getSafeDebounceResize(this._onResize, debounce);
        }
    }
    componentDidMount() {
        listeners.push(this._onResizeInvoker);
    }
    componentWillUnmount() {
        listeners = listeners.filter((listener) => listener !== this._onResizeInvoker);
    }
    render() {
        if (this.state.visible) {
            const { children } = this.props;
            if (children !== undefined) {
                return children;
            }
        }
        return null;
    }
}
exports.default = Hidden;
